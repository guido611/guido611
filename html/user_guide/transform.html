

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Data Transformations &mdash; sphinx-test 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Bindings, Selections, Conditions: Making Charts Interactive" href="interactions.html" />
    <link rel="prev" title="Marks" href="marks.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> sphinx-test
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/starting.html">Basic Statistical Visualization</a></li>
</ul>
<p class="caption"><span class="caption-text">Gallery</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../gallery/index.html">Example Gallery</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="data.html">Specifying Data in Altair</a></li>
<li class="toctree-l1"><a class="reference internal" href="encoding.html">Encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="marks.html">Marks</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Data Transformations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#aggregate-transforms">Aggregate Transforms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#transform-options">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bin-transforms">Bin transforms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#calculate-transform">Calculate Transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#filter-transform">Filter Transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#filter-expression">Filter Expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="#field-predicates">Field Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#selection-predicates">Selection Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logical-operands">Logical Operands</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#flatten-transform">Flatten Transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fold-transform">Fold Transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#impute-transform">Impute Transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#impute-via-encodings">Impute via Encodings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#impute-via-transform">Impute via Transform</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#join-aggregate-transform">Join Aggregate Transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#lookup-transform">Lookup Transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#combining-datasets-with-pandas-merge">Combining Datasets with pandas.merge</a></li>
<li class="toctree-l3"><a class="reference internal" href="#combining-datasets-with-a-lookup-transform">Combining Datasets with a Lookup Transform</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-lookup-transforms-for-geographical-visualization">Example: Lookup Transforms for Geographical Visualization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sample-transform">Sample Transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#stack-transform">Stack Transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#timeunit-transform">TimeUnit Transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#timeunit-within-encoding">TimeUnit Within Encoding</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timeunit-as-a-transform">TimeUnit as a Transform</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">Transform Options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#window-transform">Window Transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id12">Transform Options</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="interactions.html">Bindings, Selections, Conditions: Making Charts Interactive</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Top-Level Chart Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="compound_charts.html">Compound Charts: Layer, HConcat, VConcat, Repeat, Facet</a></li>
<li class="toctree-l1"><a class="reference internal" href="saving_charts.html">Saving Altair Charts</a></li>
<li class="toctree-l1"><a class="reference internal" href="customization.html">Customizing Visualizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="times_and_dates.html">Times and Dates in Altair</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="troubleshooting.html">Display Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="renderers.html">Altair Renderers</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals.html">Altair Internals: Understanding the Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="API.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="ecosystem.html">Altair Ecosystem</a></li>
</ul>
<p class="caption"><span class="caption-text">Case Studies</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../case_studies/exploring-weather.html">Exploring Seattle Weather</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="importing.html">Importing Vega &amp; Vega-Lite Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="display_frontends.html">Displaying Charts in Various Frontends</a></li>
<li class="toctree-l1"><a class="reference internal" href="custom_renderers.html">Customizing Renderers</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_transformers.html">Data transformers</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">sphinx-test</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Data Transformations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/user_guide/transform.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="data-transformations">
<span id="user-guide-transformations"></span><h1>Data Transformations<a class="headerlink" href="#data-transformations" title="Permalink to this headline">¶</a></h1>
<p>It is often necessary to transform or filter data in the process of visualizing
it. In Altair you can do this one of two ways:</p>
<ol class="arabic simple">
<li><p>Before the chart definition, using standard Pandas data transformations.</p></li>
<li><p>Within the chart definition, using Vega-Lite’s data transformation tools.</p></li>
</ol>
<p>In most cases, we suggest that you use the first approach, because it is more
straightforward to those who are familiar with data manipulation in Python, and
because the Pandas package offers much more flexibility than Vega-Lite in
available data manipulations.</p>
<p>The second approach becomes useful when the data source is not a dataframe, but,
for example, a URL pointer to a JSON or CSV file. It can also be useful in a
compound chart where different views of the dataset require different
transformations.</p>
<p>This second approach – specifying data transformations within the chart
specification itself – can be accomplished using the <code class="docutils literal notranslate"><span class="pre">transform_*</span></code>
methods of top-level objects:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Transform</p></th>
<th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#user-guide-aggregate-transform"><span class="std std-ref">Aggregate Transforms</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_aggregate()</span></code></p></td>
<td><p>Create a new data column by aggregating an existing column.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#user-guide-bin-transform"><span class="std std-ref">Bin transforms</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_bin()</span></code></p></td>
<td><p>Create a new data column by binning an existing column.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#user-guide-calculate-transform"><span class="std std-ref">Calculate Transform</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_calculate()</span></code></p></td>
<td><p>Create a new data column using an arithmetic calculation on an existing column.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#user-guide-filter-transform"><span class="std std-ref">Filter Transform</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_filter()</span></code></p></td>
<td><p>Select a subset of data based on a condition.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#user-guide-flatten-transform"><span class="std std-ref">Flatten Transform</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_flatten()</span></code></p></td>
<td><p>Flatten array data into columns.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#user-guide-fold-transform"><span class="std std-ref">Fold Transform</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_fold()</span></code></p></td>
<td><p>Convert wide-form data into long-form data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#user-guide-impute-transform"><span class="std std-ref">Impute Transform</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_impute()</span></code></p></td>
<td><p>Impute missing data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#user-guide-joinaggregate-transform"><span class="std std-ref">Join Aggregate Transform</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_joinaggregate()</span></code></p></td>
<td><p>Aggregate transform joined to original data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#user-guide-lookup-transform"><span class="std std-ref">Lookup Transform</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_lookup()</span></code></p></td>
<td><p>One-sided join of two datasets based on a lookup key.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#user-guide-sample-transform"><span class="std std-ref">Sample Transform</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_sample()</span></code></p></td>
<td><p>Random sub-sample of the rows in the dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#user-guide-stack-transform"><span class="std std-ref">Stack Transform</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_stack()</span></code></p></td>
<td><p>Compute stacked version of values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#user-guide-timeunit-transform"><span class="std std-ref">TimeUnit Transform</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_timeunit()</span></code></p></td>
<td><p>Discretize/group a date by a time unit (day, month, year, etc.)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#user-guide-window-transform"><span class="std std-ref">Window Transform</span></a></p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_window()</span></code></p></td>
<td><p>Compute a windowed aggregation</p></td>
</tr>
</tbody>
</table>
<p>We will see some examples of these transforms in the following sections.</p>
<div class="section" id="aggregate-transforms">
<span id="user-guide-aggregate-transform"></span><h2>Aggregate Transforms<a class="headerlink" href="#aggregate-transforms" title="Permalink to this headline">¶</a></h2>
<p>There are two ways to aggregate data within Altair: within the encoding itself,
or using a top level aggregate transform.</p>
<p>The aggregate property of a field definition can be used to compute aggregate
summary statistics (e.g., median, min, max) over groups of data.</p>
<p>If at least one fields in the specified encoding channels contain aggregate,
the resulting visualization will show aggregate data. In this case, all
fields without aggregation function specified are treated as group-by fields
in the aggregation process.</p>
<p>For example, the following bar chart aggregates mean of <code class="docutils literal notranslate"><span class="pre">acceleration</span></code>,
grouped by the number of Cylinders.</p>
<p>The Altair shorthand string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ...</span>
<span class="n">y</span><span class="o">=</span><span class="s1">&#39;mean(acceleration):Q&#39;</span><span class="p">,</span>
<span class="c1"># ...</span>
</pre></div>
</div>
<p>is made available for convenience, and is equivalent to the longer form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ...</span>
<span class="n">y</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="s1">&#39;acceleration&#39;</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;quantitative&#39;</span><span class="p">),</span>
<span class="c1"># ...</span>
</pre></div>
</div>
<p>For more information on shorthand encodings specifications, see
<a class="reference internal" href="encoding.html#encoding-aggregates"><span class="std std-ref">Binning and Aggregation</span></a>.</p>
<p>The same plot can be shown using an explicitly computed aggregation, using the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_aggregate()</span></code> method:</p>
<p>For a list of available aggregates, see <a class="reference internal" href="encoding.html#encoding-aggregates"><span class="std std-ref">Binning and Aggregation</span></a>.</p>
<div class="section" id="transform-options">
<h3>Transform Options<a class="headerlink" href="#transform-options" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_aggregate()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">AggregateTransform</span></code>
class, which has the following options:</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">AggregatedFieldDef</span></code> objects have the following options:</p>
</div>
</div>
<div class="section" id="bin-transforms">
<span id="user-guide-bin-transform"></span><h2>Bin transforms<a class="headerlink" href="#bin-transforms" title="Permalink to this headline">¶</a></h2>
<p>As with <a class="reference internal" href="#user-guide-aggregate-transform"><span class="std std-ref">Aggregate Transforms</span></a>, there are two ways to apply
a bin transform in Altair: within the encoding itself, or using a top-level
bin transform.</p>
<p>An common application of a bin transform is when creating a histogram:</p>
<p>But a bin transform can be useful in other applications; for example, here we
bin a continuous field to create a discrete color map:</p>
<p>In the first case we set <code class="docutils literal notranslate"><span class="pre">bin</span> <span class="pre">=</span> <span class="pre">True</span></code>, which uses the default bin settings.
In the second case, we exercise more fine-tuned control over the bin parameters
by passing a <code class="xref py py-class docutils literal notranslate"><span class="pre">Bin</span></code> object.</p>
<p>If you are using the same binnings in multiple chart components, it can be useful
to instead define the binning at the top level, using <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_bin()</span></code>
method.</p>
<p>Here is the above histogram created using a top-level bin transform:</p>
<p>And here is the transformed color scale using a top-level bin transform:</p>
<p>The advantage of the top-level transform is that the same named field can be
used in multiple places in the chart if desired.
Note the slight difference in binning behavior between the encoding-based binnings
(which preserve the range of the bins) and the transform-based binnings (which
collapse each bin to a single representative value.</p>
<div class="section" id="id1">
<h3>Transform Options<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_bin()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">BinTransform</span></code>
class, which has the following options:</p>
</div>
</div>
<div class="section" id="calculate-transform">
<span id="user-guide-calculate-transform"></span><h2>Calculate Transform<a class="headerlink" href="#calculate-transform" title="Permalink to this headline">¶</a></h2>
<p>The calculate transform allows the user to define new fields in the dataset
which are calculated from other fields using an expression syntax.</p>
<p>As a simple example, here we take data with a simple input sequence, and compute
a some trigonometric quantities:</p>
<p>Each argument within <code class="docutils literal notranslate"><span class="pre">transform_calculate</span></code> is a <a class="reference external" href="https://vega.github.io/vega/docs/expressions/">Vega expression</a> string,
which is a well-defined set of javascript-style operations that can be used
to calculate a new field from an existing one.</p>
<p>To streamline building these vega expressions in Python, Altair provides the
<code class="xref py py-mod docutils literal notranslate"><span class="pre">altair.expr</span></code> module which provides constants and functions to allow
these expressions to be constructed with Python syntax; for example:</p>
<p>Altair expressions are designed to output valid Vega expressions. The benefit of
using them is that proper syntax is ensured by the Python interpreter, and tab
completion of the <code class="xref py py-mod docutils literal notranslate"><span class="pre">expr</span></code> submodule can be used to explore the
available functions and constants.</p>
<p>These expressions can also be used when constructing a
<a class="reference internal" href="#user-guide-filter-transform"><span class="std std-ref">Filter Transform</span></a>, as we shall see next.</p>
<div class="section" id="id2">
<h3>Transform Options<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_calculate()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">CalculateTransform</span></code>
class, which has the following options:</p>
</div>
</div>
<div class="section" id="filter-transform">
<span id="user-guide-filter-transform"></span><h2>Filter Transform<a class="headerlink" href="#filter-transform" title="Permalink to this headline">¶</a></h2>
<p>The filter transform removes objects from a data stream based on a provided
filter expression, selection, or other filter predicate. A filter can be
added at the top level of a chart using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Chart.transform_filter()</span></code>
method. The argument to <code class="docutils literal notranslate"><span class="pre">transform_filter</span></code> can be one of a number of
expressions and objects:</p>
<ol class="arabic simple">
<li><p>A <a class="reference external" href="https://vega.github.io/vega/docs/expressions/">Vega expression</a> expressed as a string or built using the <code class="xref py py-mod docutils literal notranslate"><span class="pre">expr</span></code> module</p></li>
<li><p>A Field predicate, such as <code class="xref py py-class docutils literal notranslate"><span class="pre">FieldOneOfPredicate</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">FieldRangePredicate</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">FieldEqualPredicate</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">FieldLTPredicate</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">FieldGTPredicate</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">FieldLTEPredicate</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">FieldGTEPredicate</span></code>,</p></li>
<li><p>A Selection predicate or object created by <code class="xref py py-func docutils literal notranslate"><span class="pre">selection()</span></code></p></li>
<li><p>A Logical operand that combines any of the above</p></li>
</ol>
<p>We’ll show a brief example of each of these in the following sections</p>
<div class="section" id="filter-expression">
<h3>Filter Expression<a class="headerlink" href="#filter-expression" title="Permalink to this headline">¶</a></h3>
<p>A filter expression uses the <a class="reference external" href="https://vega.github.io/vega/docs/expressions/">Vega expression</a> language, either specified
directly as a string, or built using the <code class="xref py py-mod docutils literal notranslate"><span class="pre">expr</span></code> module.
This can be useful when, for example, selecting only a subset of data.</p>
<p>For example:</p>
<p>Notice that, like in the <a class="reference internal" href="#user-guide-filter-transform"><span class="std std-ref">Filter Transform</span></a>, data values are
referenced via the name <code class="docutils literal notranslate"><span class="pre">datum</span></code>.</p>
</div>
<div class="section" id="field-predicates">
<h3>Field Predicates<a class="headerlink" href="#field-predicates" title="Permalink to this headline">¶</a></h3>
<p>Field predicates overlap somewhat in function with expression predicates, but
have the advantage that their contents are validated by the schema. Examples
are:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">FieldEqualPredicate</span></code> evaluates whether a field is equal to
a particular value</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">FieldOneOfPredicate</span></code> evaluates whether a field is among a list of
specified values.</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">FieldRangePredicate</span></code> evaluates whether a continuous field is within
a range of values.</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">FieldLTPredicate</span></code> evaluates whether a continuous field is less
than a given value</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">FieldGTPredicate</span></code> evaluates whether a continuous field is greater
than a given value</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">FieldLTEPredicate</span></code> evaluates whether a continuous field is less
than or equal to a given value</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">FieldGTEPredicate</span></code> evaluates whether a continuous field is greater
than or equal to a given value</p></li>
</ul>
<p>Here is an example of a <code class="xref py py-class docutils literal notranslate"><span class="pre">FieldEqualPredicate</span></code> used to select just the
values from year 2000 as in the above chart:</p>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">FieldOneOfPredicate</span></code> is similar, but allows selection of any number
of specific values:</p>
<p>Finally, a <code class="xref py py-meth docutils literal notranslate"><span class="pre">FieldRangePredicate()</span></code> allows selecting values within a
particular continuous range:</p>
</div>
<div class="section" id="selection-predicates">
<h3>Selection Predicates<a class="headerlink" href="#selection-predicates" title="Permalink to this headline">¶</a></h3>
<p>Selection predicates can be used to filter data based on a selection. While
these can be constructed directly using a <code class="xref py py-class docutils literal notranslate"><span class="pre">SelectionPredicate</span></code> class,
in Altair it is often more convenient to construct them using the
<code class="xref py py-func docutils literal notranslate"><span class="pre">selection()</span></code> function. For example, this chart uses a multi-selection
that allows the user to click or shift-click on the bars in the bottom chart
to select the data to be shown in the top chart:</p>
</div>
<div class="section" id="logical-operands">
<h3>Logical Operands<a class="headerlink" href="#logical-operands" title="Permalink to this headline">¶</a></h3>
<p>At times it is useful to combine several types of predicates into a single
selection. This can be accomplished using the various logical operand classes:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">LogicalOrPredicate</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">LogicalAndPredicate</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">LogicalNotPredicate</span></code></p></li>
</ul>
<p>These are not yet part of the Altair interface
(see <a class="reference external" href="https://github.com/altair-viz/altair/issues/695">Issue 695</a>)
but can be constructed explicitly; for example, here we plot US population
distributions for all data <em>except</em> the years 1950-1960,
by applying a <code class="docutils literal notranslate"><span class="pre">LogicalNotPredicate</span></code> schema to a <code class="docutils literal notranslate"><span class="pre">FieldRangePredicate</span></code>:</p>
</div>
<div class="section" id="id3">
<h3>Transform Options<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_filter()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">FilterTransform</span></code>
class, which has the following options:</p>
</div>
</div>
<div class="section" id="flatten-transform">
<span id="user-guide-flatten-transform"></span><h2>Flatten Transform<a class="headerlink" href="#flatten-transform" title="Permalink to this headline">¶</a></h2>
<p>The flatten transform can be used to extract the contents of arrays from data entries.
This will not generally be useful for well-structured data within pandas dataframes,
but it can be useful for working with data from other sources.</p>
<p>As an example, consider this dataset which uses a common convention in JSON data,
a set of fields each containing a list of entries:</p>
<p>This kind of data structure does not work well in the context of dataframe
representations, as we can see by loading this into pandas:</p>
<p>Alair’s flatten transform allows you to extract the contents of these arrays
into a column that can be referenced by an encoding:</p>
<p>This can be particularly useful in cleaning up data specified via a JSON URL,
without having to first load the data for manipulation in pandas.</p>
<div class="section" id="id4">
<h3>Transform Options<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_flatten()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">FlattenTransform</span></code>
class, which has the following options:</p>
</div>
</div>
<div class="section" id="fold-transform">
<span id="user-guide-fold-transform"></span><h2>Fold Transform<a class="headerlink" href="#fold-transform" title="Permalink to this headline">¶</a></h2>
<p>The fold transform is, in short, a way to convert wide-form data to long-form
data directly without any preprocessing (see <a class="reference internal" href="data.html#data-long-vs-wide"><span class="std std-ref">Long-form vs. Wide-form Data</span></a> for more
information).</p>
<p>So, for example, if your data consist of multiple columns that record parallel
data for different categories, you can use the fold transform to encode based
on those categories:</p>
<p>Notice here that the fold transform essentially stacks all the values
from the specified columns into a single new field named <code class="docutils literal notranslate"><span class="pre">&quot;value&quot;</span></code>,
with the associated names in a field named <code class="docutils literal notranslate"><span class="pre">&quot;key&quot;</span></code>.</p>
<p>For an example of the fold transform in action, see <span class="xref std std-ref">gallery_parallel_coordinates</span>.</p>
<div class="section" id="id5">
<h3>Transform Options<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_fold()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">FoldTransform</span></code>
class, which has the following options:</p>
</div>
</div>
<div class="section" id="impute-transform">
<span id="user-guide-impute-transform"></span><h2>Impute Transform<a class="headerlink" href="#impute-transform" title="Permalink to this headline">¶</a></h2>
<p>The impute transform allows you to fill-in missing entries in a dataset.
As an example, consider the following data, which includes missing values
that we filter-out of the long-form representation (see <a class="reference internal" href="data.html#data-long-vs-wide"><span class="std std-ref">Long-form vs. Wide-form Data</span></a>
for more on this):</p>
<p>Notice the result: the <code class="docutils literal notranslate"><span class="pre">x</span></code> series has no entry at <code class="docutils literal notranslate"><span class="pre">t=1</span></code>, and the <code class="docutils literal notranslate"><span class="pre">y</span></code>
series has a missing entry at <code class="docutils literal notranslate"><span class="pre">t=3</span></code>. If we use Altair to visualize this
data directly, the line skips the missing entries:</p>
<p>This is not always desireable, because (particularly for a line plot with
no points) it can imply the esistence of data that is not there.</p>
<div class="section" id="impute-via-encodings">
<h3>Impute via Encodings<a class="headerlink" href="#impute-via-encodings" title="Permalink to this headline">¶</a></h3>
<p>To address this, you can use an impute argument to the encoding channel.
For example, we can impute using a constant value (we’ll show the raw chart
lightly in the background for reference):</p>
<p>Or we can impute using any supported aggregate:</p>
</div>
<div class="section" id="impute-via-transform">
<h3>Impute via Transform<a class="headerlink" href="#impute-via-transform" title="Permalink to this headline">¶</a></h3>
<p>Similar to the <a class="reference internal" href="#user-guide-bin-transform"><span class="std std-ref">Bin transforms</span></a> and <a class="reference internal" href="#user-guide-aggregate-transform"><span class="std std-ref">Aggregate Transforms</span></a>,
it is also possible to specify the impute transform outside the encoding as a
transform. For example, here is the equivalent of the above two charts:</p>
<p>If you would like to use more localized imputed values, you can specify a
<code class="docutils literal notranslate"><span class="pre">frame</span></code> parameter similar to the <a class="reference internal" href="#user-guide-window-transform"><span class="std std-ref">Window Transform</span></a> that
will control which values are used for the imputation. For example, here
we impute missing values using the mean of the neighboring points on either
side:</p>
</div>
<div class="section" id="id6">
<h3>Transform Options<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_impute()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">ImputeTransform</span></code>
class, which has the following options:</p>
</div>
</div>
<div class="section" id="join-aggregate-transform">
<span id="user-guide-joinaggregate-transform"></span><h2>Join Aggregate Transform<a class="headerlink" href="#join-aggregate-transform" title="Permalink to this headline">¶</a></h2>
<p>The Join Aggregate transform acts in almost every way the same as an Aggregate
transform, but the resulting aggregate is joined to the original dataset.
To make this more clear, consider the following dataset:</p>
<p>Here is a pandas operation that is equivalent to Altair’s Aggregate transform,
using the mean as an example:</p>
<p>And here is an output that is equivalent to Altair’s Join Aggregate:</p>
<p>Notice that the join aggregate joins the aggregated value with the original
dataframe, such that the aggregated values can be used in tandem with the
original values if desired.</p>
<p>Here is an example of how the join aggregate might be used: we compare the
IMDB and Rotten Tomatoes movie ratings, normalized by their mean and
standard deviation, which requires calculations on the joined data:</p>
<div class="section" id="id7">
<h3>Transform Options<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_joinaggregate()</span></code> method is built on the
<code class="xref py py-class docutils literal notranslate"><span class="pre">JoinAggregateTransform</span></code> class, which has the following options:</p>
</div>
</div>
<div class="section" id="lookup-transform">
<span id="user-guide-lookup-transform"></span><h2>Lookup Transform<a class="headerlink" href="#lookup-transform" title="Permalink to this headline">¶</a></h2>
<p>The Lookup transform extends a primary data source by looking up values from
another data source; it is similar to a one-sided join. A lookup can be added
at the top level of a chart using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Chart.transform_lookup()</span></code> method.</p>
<p>By way of example, imagine you have two sources of data that you would like
to combine and plot: one is a list of names of people along with their height
and weight, and the other is some information about which groups they belong
to. This example data is available in <code class="docutils literal notranslate"><span class="pre">vega_datasets</span></code>:</p>
<p>We know how to visualize each of these datasets separately; for example:</p>
<p>If we would like to plot features that reference both datasets (for example, the
average age within each group), we need to combine the two datasets.
This can be done either as a data preprocessing step, using tools available
in Pandas, or as part of the visualization using a <code class="xref py py-class docutils literal notranslate"><span class="pre">LookupTransform</span></code>
in Altair.</p>
<div class="section" id="combining-datasets-with-pandas-merge">
<h3>Combining Datasets with pandas.merge<a class="headerlink" href="#combining-datasets-with-pandas-merge" title="Permalink to this headline">¶</a></h3>
<p>Pandas provides a wide range of tools for merging and joining datasets; see
<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/merging.html">Merge, Join, and Concatenate</a>
for some detailed examples.
For the above data, we can merge the data and create a combined chart as follows:</p>
<p>We specify a left join, meaning that for each entry of the “person” column in
the groups, we seek the “name” column in people and add the entry to the data.
From this, we can easily create a bar chart representing the mean age in each group.</p>
</div>
<div class="section" id="combining-datasets-with-a-lookup-transform">
<h3>Combining Datasets with a Lookup Transform<a class="headerlink" href="#combining-datasets-with-a-lookup-transform" title="Permalink to this headline">¶</a></h3>
<p>For some data sources (e.g. data available at a URL, or data that is streaming),
it is desirable to have a means of joining data without having to download
it for pre-processing in Pandas.
This is where Altair’s <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_lookup()</span></code> comes in.
To reproduce the above combined plot by combining datasets within the
chart specification itself, we can do the following:</p>
<p>Here <code class="docutils literal notranslate"><span class="pre">lookup</span></code> names the field in the groups dataset on which we will match,
and the <code class="docutils literal notranslate"><span class="pre">from_</span></code> argument specifies a <code class="xref py py-class docutils literal notranslate"><span class="pre">LookupData</span></code> structure where
we supply the second dataset, the lookup key, and the fields we would like to
extract.</p>
</div>
<div class="section" id="example-lookup-transforms-for-geographical-visualization">
<h3>Example: Lookup Transforms for Geographical Visualization<a class="headerlink" href="#example-lookup-transforms-for-geographical-visualization" title="Permalink to this headline">¶</a></h3>
<p>Lookup transforms are often particularly important for geographic visualization,
where it is common to combine tabular datasets with datasets that specify
geographic boundaries to be visualized; for example, here is a visualization
of unemployment rates per county in the US:</p>
</div>
<div class="section" id="id8">
<h3>Transform Options<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_lookup()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">LookupTransform</span></code>
class, which has the following options:</p>
</div>
</div>
<div class="section" id="sample-transform">
<span id="user-guide-sample-transform"></span><h2>Sample Transform<a class="headerlink" href="#sample-transform" title="Permalink to this headline">¶</a></h2>
<p>The sample transform is one of the simpler of all Altair’s data transforms;
it takes a single parameter <code class="docutils literal notranslate"><span class="pre">sample</span></code> which specified a number of rows to
randomly choose from the dataset. The resulting chart will be created using
only this random subset of the data.</p>
<p>For example, here we chart the full cars dataset alongside a sample of 100
rows:</p>
<div class="section" id="id9">
<h3>Transform Options<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_sample()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">SampleTransform</span></code>
class, which has the following options:</p>
</div>
</div>
<div class="section" id="stack-transform">
<span id="user-guide-stack-transform"></span><h2>Stack Transform<a class="headerlink" href="#stack-transform" title="Permalink to this headline">¶</a></h2>
<p>The stack transform allows you to compute values associated with stacked versions
of encodings. For example, consider this stacked bar chart:</p>
<p>Implicitly, this data is being grouped and stacked, but what if you would like to
access those stacked values directly?
We can construct that same chart manually using the stack transform:</p>
<p>Notice that the bars are now explicitly drawn between values computed and
specified within the x and x2 encodings.</p>
<div class="section" id="id10">
<h3>Transform Options<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_stack()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">StackTransform</span></code>
class, which has the following options:</p>
</div>
</div>
<div class="section" id="timeunit-transform">
<span id="user-guide-timeunit-transform"></span><h2>TimeUnit Transform<a class="headerlink" href="#timeunit-transform" title="Permalink to this headline">¶</a></h2>
<p>TimeUnit transforms are used to discretize dates and times within Altair.
As with the <a class="reference internal" href="#user-guide-aggregate-transform"><span class="std std-ref">Aggregate Transforms</span></a> and <a class="reference internal" href="#user-guide-bin-transform"><span class="std std-ref">Bin transforms</span></a>
discussed above, they can be defined either as part of the encoding, or as a
top-level transform.</p>
<p>These are the available time units:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;year&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;yearquarter&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;yearquartermonth&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;yearmonth&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;yearmonthdate&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;yearmonthdatehours&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;yearmonthdatehoursminutes&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;yearmonthdatehoursseconds&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;quarter&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;quartermonth&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;month&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;monthdate&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;date&quot;</span></code> (Day of month, i.e., 1 - 31)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;day&quot;</span></code> (Day of week, i.e., Monday - Friday)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;hours&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;hoursminutes&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;hoursminutesseconds&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;minutes&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;minutesseconds&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;seconds&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;secondsmilliseconds&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;milliseconds&quot;</span></code></p></li>
</ul>
<div class="section" id="timeunit-within-encoding">
<h3>TimeUnit Within Encoding<a class="headerlink" href="#timeunit-within-encoding" title="Permalink to this headline">¶</a></h3>
<p>Any temporal field definition can include a <code class="docutils literal notranslate"><span class="pre">timeUnit</span></code> argument to discretize
the temporal data.</p>
<p>For example, here we plot a dataset that consists of hourly temperature
measurements in Seattle during the year 2010:</p>
<p>The plot is too busy due to the amount of data points squeezed into the short
time; we can make it a bit cleaner by discretizing it, for example, by month
and plotting only the mean monthly temperature:</p>
<p>Notice that by default timeUnit output is a continuous quantity; if you would
instead like it to be a categorical, you can specify the ordinal (<code class="docutils literal notranslate"><span class="pre">O</span></code>) or
nominal (<code class="docutils literal notranslate"><span class="pre">N</span></code>) type.
This can be useful when plotting a bar chart or other discrete chart type:</p>
<p>Multiple time units can be combined within a single plot to yield interesting
views of your data; for example, here we extract both the month and the day
to give a profile of Seattle temperatures through the year:</p>
</div>
<div class="section" id="timeunit-as-a-transform">
<h3>TimeUnit as a Transform<a class="headerlink" href="#timeunit-as-a-transform" title="Permalink to this headline">¶</a></h3>
<p>Other times it is convenient to specify a timeUnit as a top-level transform,
particularly when the value may be reused.
This can be done most conveniently using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Chart.transform_timeunit()</span></code>
method. For example:</p>
<p>Notice that because the <code class="docutils literal notranslate"><span class="pre">timeUnit</span></code> is not part of the encoding channel here,
it is often necessary to add an axis formatter to ensure appropriate axis
labels.</p>
</div>
<div class="section" id="id11">
<h3>Transform Options<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_timeunit()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">TimeUnitTransform</span></code>
class, which has the following options:</p>
</div>
</div>
<div class="section" id="window-transform">
<span id="user-guide-window-transform"></span><h2>Window Transform<a class="headerlink" href="#window-transform" title="Permalink to this headline">¶</a></h2>
<p>The window transform performs calculations over sorted groups of data objects.
These calculations include ranking, lead/lag analysis, and aggregates such as cumulative sums and averages.
Calculated values are written back to the input data stream, where they can be referenced by encodings.</p>
<p>For example, consider the following cumulative frequency distribution:</p>
<p>First, we pass a sort field definition, which indicates how data objects should be sorted within the window.
Here, movies should be sorted by their IMDB rating.
Next, we pass the frame, which indicates how many data objects before and after the current data object should be included within the window.
Here, all movies up to and including the current movie should be included.
Finally, we pass a window field definition, which indicates how data objects should be aggregated within the window.
Here, the number of movies should be counted.</p>
<p>There are many aggregation functions built into Altair.
As well as those given in <a class="reference internal" href="encoding.html#encoding-aggregates"><span class="std std-ref">Binning and Aggregation</span></a>, we can use the following within window field definitions:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 4%" />
<col style="width: 3%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Aggregate</p></th>
<th class="head"><p>Parameter</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>row_number</p></td>
<td><p>None</p></td>
<td><p>Assigns each data object a consecutive row number, starting from 1.</p></td>
</tr>
<tr class="row-odd"><td><p>rank</p></td>
<td><p>None</p></td>
<td><p>Assigns a rank order value to each data object in a window, starting from 1. Peer values are assigned the same rank. Subsequent rank scores incorporate the number of prior values. For example, if the first two values tie for rank 1, the third value is assigned rank 3.</p></td>
</tr>
<tr class="row-even"><td><p>dense_rank</p></td>
<td><p>None</p></td>
<td><p>Assigns dense rank order values to each data object in a window, starting from 1. Peer values are assigned the same rank. Subsequent rank scores do not incorporate the number of prior values. For example, if the first two values tie for rank 1, the third value is assigned rank 2.</p></td>
</tr>
<tr class="row-odd"><td><p>percent_rank</p></td>
<td><p>None</p></td>
<td><p>Assigns a percentage rank order value to each data object in a window. The percent is calculated as (rank - 1) / (group_size - 1).</p></td>
</tr>
<tr class="row-even"><td><p>cume_dist</p></td>
<td><p>None</p></td>
<td><p>Assigns a cumulative distribution value between 0 and 1 to each data object in a window.</p></td>
</tr>
<tr class="row-odd"><td><p>ntile</p></td>
<td><p>Number</p></td>
<td><p>Assigns a quantile (e.g., percentile) value to each data object in a window. Accepts an integer parameter indicating the number of buckets to use (e.g., 100 for percentiles, 5 for quintiles).</p></td>
</tr>
<tr class="row-even"><td><p>lag</p></td>
<td><p>Number</p></td>
<td><p>Assigns a value from the data object that precedes the current object by a specified number of positions. If no such object exists, assigns <code class="docutils literal notranslate"><span class="pre">null</span></code>. Accepts an offset parameter (default <code class="docutils literal notranslate"><span class="pre">1</span></code>) that indicates the number of positions. This operation must have a corresponding entry in the <cite>fields</cite> parameter array.</p></td>
</tr>
<tr class="row-odd"><td><p>lead</p></td>
<td><p>Number</p></td>
<td><p>Assigns a value from the data object that follows the current object by a specified number of positions. If no such object exists, assigns <code class="docutils literal notranslate"><span class="pre">null</span></code>. Accepts an offset parameter (default <code class="docutils literal notranslate"><span class="pre">1</span></code>) that indicates the number of positions. This operation must have a corresponding entry in the <cite>fields</cite> parameter array.</p></td>
</tr>
<tr class="row-even"><td><p>first_value</p></td>
<td><p>None</p></td>
<td><p>Assigns a value from the first data object in the current sliding window frame. This operation must have a corresponding entry in the <cite>fields</cite> parameter array.</p></td>
</tr>
<tr class="row-odd"><td><p>last_value</p></td>
<td><p>None</p></td>
<td><p>Assigns a value from the last data object in the current sliding window frame. This operation must have a corresponding entry in the <cite>fields</cite> parameter array.</p></td>
</tr>
<tr class="row-even"><td><p>nth_value</p></td>
<td><p>Number</p></td>
<td><p>Assigns a value from the nth data object in the current sliding window frame. If no such object exists, assigns <code class="docutils literal notranslate"><span class="pre">null</span></code>. Requires a non-negative integer parameter that indicates the offset from the start of the window frame. This operation must have a corresponding entry in the <cite>fields</cite> parameter array.</p></td>
</tr>
</tbody>
</table>
<p>While an aggregate transform computes a single value that summarises all data objects, a window transform adds a new property to each data object.
This new property is computed from the neighbouring data objects: that is, from the data objects delimited by the window field definition.
For example, consider the following time series of stock prices:</p>
<p>It’s hard to see the overall pattern in the above example, because Google’s stock price is much higher than the other stock prices.
If we plot the <a class="reference external" href="https://en.wikipedia.org/w/index.php?title=Z-score">z-scores</a> of the stock prices, rather than the stock prices themselves, then the overall pattern becomes clearer:</p>
<p>By using two aggregation functions (<code class="docutils literal notranslate"><span class="pre">mean</span></code> and <code class="docutils literal notranslate"><span class="pre">stdev</span></code>) within the window transform, we are able to compute the z-scores within the calculate transform.</p>
<p>For more information about the arguments to the window transform, see <code class="xref py py-class docutils literal notranslate"><span class="pre">WindowTransform</span></code> and <a class="reference external" href="https://vega.github.io/vega-lite/docs/window.html">the Vega-Lite documentation</a>.</p>
<div class="section" id="id12">
<h3>Transform Options<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_window()</span></code> method is built on the <code class="xref py py-class docutils literal notranslate"><span class="pre">WindowTransform</span></code>
class, which has the following options:</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="interactions.html" class="btn btn-neutral float-right" title="Bindings, Selections, Conditions: Making Charts Interactive" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="marks.html" class="btn btn-neutral float-left" title="Marks" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Guido Drechsel

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>